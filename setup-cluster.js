const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

class ClusterSetup {
    constructor() {
        this.configFile = 'cluster-config.json';
        this.knownNodesFile = 'known_nodes.json';
    }

    getLocalIPs() {
        const interfaces = os.networkInterfaces();
        const addresses = [];
        
        for (const name of Object.keys(interfaces)) {
            for (const interface of interfaces[name]) {
                if (interface.family === 'IPv4' && !interface.internal) {
                    addresses.push(interface.address);
                }
            }
        }
        
        return addresses;
    }

    async createDefaultConfig() {
        const localIPs = this.getLocalIPs();
        const defaultPort = 3000;
        
        const config = {
            nodeId: localIPs.length > 0 ? `${localIPs[0]}:${defaultPort}` : `localhost:${defaultPort}`,
            port: defaultPort,
            database: {
                host: 'localhost',
                user: 'root',
                password: 'password',
                database: 'galaga'
            },
            cluster: {
                heartbeatInterval: 5000,
                replicationTimeout: 5000,
                maxReconnectAttempts: 3,
                healthCheckFrequency: 10000
            },
            knownNodes: [],
            autoDiscovery: {
                enabled: true,
                ipRanges: [
                    '192.168.1.0/24',
                    '25.0.0.0/24'
                ],
                ports: [3000, 3001, 3002]
            }
        };

        try {
            await fs.writeFile(this.configFile, JSON.stringify(config, null, 2));
            console.log(`‚úÖ Archivo de configuraci√≥n creado: ${this.configFile}`);
            return config;
        } catch (error) {
            console.error('‚ùå Error creando configuraci√≥n:', error);
            throw error;
        }
    }

    async loadConfig() {
        try {
            const configData = await fs.readFile(this.configFile, 'utf8');
            return JSON.parse(configData);
        } catch (error) {
            console.log('‚öôÔ∏è No se encontr√≥ configuraci√≥n, creando una nueva...');
            return await this.createDefaultConfig();
        }
    }

    async updateKnownNodes(nodes) {
        try {
            const uniqueNodes = [...new Set(nodes)];
            await fs.writeFile(this.knownNodesFile, JSON.stringify(uniqueNodes, null, 2));
            console.log(`üìù Nodos conocidos actualizados: ${uniqueNodes.length} nodos`);
        } catch (error) {
            console.error('‚ùå Error actualizando nodos conocidos:', error);
        }
    }

    async scanNetwork(ipRange, ports) {
        console.log(`üîç Escaneando red ${ipRange} en puertos ${ports.join(', ')}...`);
        
        const [network, cidr] = ipRange.split('/');
        const [baseIP] = network.split('.');
        const baseNetwork = network.substring(0, network.lastIndexOf('.'));
        
        const foundNodes = [];
        const scanPromises = [];

        // Escanear rango de IPs
        for (let i = 1; i < 255; i++) {
            const ip = `${baseNetwork}.${i}`;
            
            for (const port of ports) {
                scanPromises.push(
                    this.checkNode(`${ip}:${port}`)
                        .then(isAlive => {
                            if (isAlive) {
                                foundNodes.push(`${ip}:${port}`);
                                console.log(`‚úÖ Nodo encontrado: ${ip}:${port}`);
                            }
                        })
                        .catch(() => {}) // Ignorar errores de conexi√≥n
                );
            }
        }

        await Promise.allSettled(scanPromises);
        return foundNodes;
    }

    async checkNode(nodeAddress) {
        try {
            const response = await fetch(`http://${nodeAddress}/api/ping`, {
                method: 'GET',
                timeout: 2000
            });
            return response.ok;
        } catch (error) {
            return false;
        }
    }

    async discoverNodes() {
        const config = await this.loadConfig();
        const allFoundNodes = [];

        if (config.autoDiscovery.enabled) {
            for (const ipRange of config.autoDiscovery.ipRanges) {
                const foundNodes = await this.scanNetwork(ipRange, config.autoDiscovery.ports);
                allFoundNodes.push(...foundNodes);
            }
        }

        // Agregar nodos conocidos manualmente
        allFoundNodes.push(...config.knownNodes);

        // Remover duplicados y el nodo actual
        const uniqueNodes = [...new Set(allFoundNodes)].filter(node => node !== config.nodeId);
        
        await this.updateKnownNodes(uniqueNodes);
        return uniqueNodes;
    }

    async generateStartupScript() {
        const config = await this.loadConfig();
        const localIPs = this.getLocalIPs();

        const startupScript = `#!/bin/bash
# Script de inicio del cluster de base de datos

echo "üöÄ Iniciando nodo del cluster..."
echo "üì° IPs locales disponibles:"
${localIPs.map(ip => `echo "  - ${ip}:${config.port}"`).join('\n')}
echo ""

# Verificar dependencias
if ! command -v node &> /dev/null; then
    echo "‚ùå Node.js no est√° instalado"
    exit 1
fi

if ! command -v mysql &> /dev/null; then
    echo "‚ö†Ô∏è MySQL no est√° disponible en PATH"
fi

# Verificar archivos necesarios
if [ ! -f "server.js" ]; then
    echo "‚ùå server.js no encontrado"
    exit 1
fi

if [ ! -f "package.json" ]; then
    echo "üì¶ Instalando dependencias..."
    npm init -y
    npm install express mysql2 cors
fi

# Crear base de datos si no existe
echo "üóÑÔ∏è Configurando base de datos..."
mysql -u${config.database.user} -p${config.database.password} -e "CREATE DATABASE IF NOT EXISTS ${config.database.database};" 2>/dev/null || echo "‚ö†Ô∏è No se pudo crear la base de datos autom√°ticamente"

# Iniciar servidor
echo "‚ñ∂Ô∏è Iniciando servidor en puerto ${config.port}..."
export PORT=${config.port}
node server.js

echo "üõë Servidor detenido"
`;

        await fs.writeFile('start-cluster.sh', startupScript);
        
        // Hacer ejecutable en sistemas Unix
        try {
            execSync('chmod +x start-cluster.sh');
        } catch (error) {
            // En Windows, ignorar este error
        }

        console.log('‚úÖ Script de inicio creado: start-cluster.sh');
    }

    async generateDocumentation() {
        const doc = `# Cluster de Base de Datos - Documentaci√≥n

## Descripci√≥n General

Este sistema implementa un cluster de base de datos MySQL con replicaci√≥n autom√°tica y failover entre m√∫ltiples nodos. Los nodos pueden actuar tanto como servidor principal (l√≠der) como r√©plicas.

## Caracter√≠sticas

- ‚úÖ **Elecci√≥n autom√°tica de l√≠der**: El nodo con menor ID se convierte en l√≠der
- ‚úÖ **Replicaci√≥n en tiempo real**: Los datos se replican autom√°ticamente a todas las r√©plicas
- ‚úÖ **Failover autom√°tico**: Los clientes se reconectan autom√°ticamente si el l√≠der falla
- ‚úÖ **Descubrimiento de nodos**: Los nodos se encuentran autom√°ticamente en la red
- ‚úÖ **Monitoreo de salud**: Heartbeat continuo entre todos los nodos
- ‚úÖ **Sincronizaci√≥n completa**: Los nodos nuevos se sincronizan autom√°ticamente

## Instalaci√≥n y Configuraci√≥n

### 1. Dependencias
\`\`\`bash
npm install express mysql2 cors
\`\`\`

### 2. Configurar MySQL
\`\`\`sql
CREATE DATABASE galaga;
CREATE USER 'root'@'%' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON galaga.* TO 'root'@'%';
FLUSH PRIVILEGES;
\`\`\`

### 3. Iniciar Nodos
En cada m√°quina que participar√° en el cluster:

\`\`\`bash
# Generar configuraci√≥n inicial
node setup-cluster.js

# Iniciar servidor
./start-cluster.sh
# o
node server.js
\`\`\`

## Archivos del Sistema

- **server.js**: Servidor principal con capacidades de replicaci√≥n
- **serverremoto.js**: Cliente con failover autom√°tico
- **setup-cluster.js**: Script de configuraci√≥n del cluster
- **cluster-config.json**: Configuraci√≥n del nodo
- **known_nodes.json**: Lista de nodos conocidos en el cluster

## API Endpoints

### Endpoints Originales
- \`GET /api/ping\` - Estado del servidor
- \`POST /api/guardar-puntuacion\` - Guardar puntuaci√≥n de juego
- \`GET /api/mejores-puntuaciones\` - Obtener mejores puntuaciones
- \`GET /api/db-status\` - Estado de la base de datos

### Endpoints de Cluster
- \`POST /api/heartbeat\` - Heartbeat entre nodos
- \`POST /api/replicate\` - Replicar operaci√≥n a r√©plica
- \`GET /api/full-sync\` - Sincronizaci√≥n completa de datos
- \`GET /api/cluster-status\` - Estado del cluster

## Monitoreo

### Ver Estado del Cluster
\`\`\`bash
curl http://localhost:3000/api/cluster-status
\`\`\`

### Logs Importantes
- **üèÜ Nodo elegido como L√çDER**: El nodo se convirti√≥ en l√≠der
- **üìã Nodo ahora es R√âPLICA**: El nodo se convirti√≥ en r√©plica
- **üîÑ Cambiando al servidor l√≠der**: Cliente detect√≥ nuevo l√≠der
- **‚úÖ Failover exitoso**: Cliente se reconect√≥ despu√©s de falla

## Soluci√≥n de Problemas

### Problema: Nodo no se conecta al cluster
1. Verificar conectividad de red entre nodos
2. Revisar archivo \`known_nodes.json\`
3. Verificar que los puertos est√©n abiertos
4. Comprobar logs de heartbeat

### Problema: Datos no se replican
1. Verificar que el nodo sea l√≠der (\`isLeader: true\`)
2. Comprobar que las r√©plicas est√©n marcadas como "healthy"
3. Revisar logs de replicaci√≥n
4. Verificar conectividad con r√©plicas

### Problema: Cliente no puede conectar
1. Verificar lista de servidores en el cliente
2. Comprobar que al menos un servidor est√© funcionando
3. Revisar logs de failover autom√°tico
4. Verificar descubrimiento autom√°tico de servidores

## Configuraci√≥n Avanzada

### Personalizar Intervalos
Editar \`cluster-config.json\`:
\`\`\`json
{
  "cluster": {
    "heartbeatInterval": 5000,      // Frecuencia de heartbeat
    "replicationTimeout": 5000,     // Timeout para replicaci√≥n
    "maxReconnectAttempts": 3,      // Intentos de reconexi√≥n
    "healthCheckFrequency": 10000   // Frecuencia de verificaci√≥n de salud
  }
}
\`\`\`

### Agregar Nodos Manualmente
\`\`\`json
{
  "knownNodes": [
    "192.168.1.100:3000",
    "192.168.1.101:3000",
    "25.0.0.1:3000"
  ]
}
\`\`\`

## Arquitectura del Sistema

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Nodo 1 (L√çDER)‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   Nodo 2        ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   Nodo 3        ‚îÇ
‚îÇ   MySQL + API   ‚îÇ    ‚îÇ   MySQL + API   ‚îÇ    ‚îÇ   MySQL + API   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚ñ≤                       ‚ñ≤                       ‚ñ≤
         ‚îÇ              Heartbeat & Replication          ‚îÇ
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ     Cliente     ‚îÇ
                    ‚îÇ  (Auto-failover)‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

## Seguridad

- Cambiar contrase√±as por defecto en producci√≥n
- Configurar firewall para permitir solo IPs autorizadas
- Usar HTTPS en lugar de HTTP para producci√≥n
- Implementar autenticaci√≥n entre nodos si es necesario
`;

        await fs.writeFile('CLUSTER-README.md', doc);
        console.log('‚úÖ Documentaci√≥n generada: CLUSTER-README.md');
    }

    async setup() {
        console.log('üîß Configurando cluster de base de datos...\n');

        try {
            // 1. Cargar/crear configuraci√≥n
            const config = await this.loadConfig();
            console.log('üìã Configuraci√≥n cargada');

            // 2. Descubrir nodos en la red
            const foundNodes = await this.discoverNodes();
            console.log(`üîç Descubrimiento completado: ${foundNodes.length} nodos encontrados`);

            // 3. Generar script de inicio
            await this.generateStartupScript();

            // 4. Generar documentaci√≥n
            await this.generateDocumentation();

            console.log('\n‚úÖ Configuraci√≥n del cluster completada');
            console.log('\nüìã Pr√≥ximos pasos:');
            console.log('1. Revisar cluster-config.json y ajustar seg√∫n sea necesario');
            console.log('2. Ejecutar ./start-cluster.sh en cada nodo');
            console.log('3. Verificar estado del cluster con: curl http://localhost:3000/api/cluster-status');
            console.log('4. Leer CLUSTER-README.md para m√°s informaci√≥n');

        } catch (error) {
            console.error('‚ùå Error durante la configuraci√≥n:', error);
            throw error;
        }
    }
}

// Ejecutar configuraci√≥n si se llama directamente
if (require.main === module) {
    const setup = new ClusterSetup();
    setup.setup().catch(console.error);
}

module.exports = ClusterSetup;